// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var ReasonReactRouter = require("reason-react/src/ReasonReactRouter.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var ReactHelper$ReactTemplate = require("./ReactHelper.bs.js");

function custom(param, stringToValue) {
  return {
          _0: (function (param) {
              var unvisited = param.unvisited;
              if (!unvisited) {
                return /* [] */0;
              }
              var next = unvisited.hd;
              var nextValue = Curry._1(stringToValue, next);
              if (nextValue.TAG === /* Ok */0) {
                return {
                        hd: {
                          visited: Belt_List.concat({
                                hd: next,
                                tl: /* [] */0
                              }, param.visited),
                          unvisited: unvisited.tl,
                          params: param.params,
                          value: Curry._1(param.value, nextValue._0)
                        },
                        tl: /* [] */0
                      };
              } else {
                return /* [] */0;
              }
            }),
          [Symbol.for("name")]: "Parser"
        };
}

function s(str) {
  return {
          _0: (function (param) {
              var unvisited = param.unvisited;
              if (!unvisited) {
                return /* [] */0;
              }
              var next = unvisited.hd;
              if (next === str) {
                return {
                        hd: {
                          visited: Belt_List.concat({
                                hd: next,
                                tl: /* [] */0
                              }, param.visited),
                          unvisited: unvisited.tl,
                          params: param.params,
                          value: param.value
                        },
                        tl: /* [] */0
                      };
              } else {
                return /* [] */0;
              }
            }),
          [Symbol.for("name")]: "Parser"
        };
}

function string(param) {
  return custom("STRING", (function (v) {
                return {
                        TAG: 0,
                        _0: v,
                        [Symbol.for("name")]: "Ok"
                      };
              }));
}

function $$int(param) {
  return custom("INT", (function (v) {
                try {
                  return {
                          TAG: 0,
                          _0: Caml_format.caml_int_of_string(v),
                          [Symbol.for("name")]: "Ok"
                        };
                }
                catch (raw_msg){
                  var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
                  if (msg.RE_EXN_ID === "Failure") {
                    return {
                            TAG: 1,
                            _0: msg._1,
                            [Symbol.for("name")]: "Error"
                          };
                  }
                  throw msg;
                }
              }));
}

function $slash(parseBefore, parseAfter) {
  var parseAfter$1 = parseAfter._0;
  var parseBefore$1 = parseBefore._0;
  return {
          _0: (function (state) {
              return Belt_List.flatten(Belt_List.map(Curry._1(parseBefore$1, state), parseAfter$1));
            }),
          [Symbol.for("name")]: "Parser"
        };
}

function mapHelp(func, param) {
  return {
          visited: param.visited,
          unvisited: param.unvisited,
          params: param.params,
          value: Curry._1(func, param.value)
        };
}

function map(subValue, parse) {
  var parse$1 = parse._0;
  return {
          _0: (function (param) {
              var value = param.value;
              var parsed = Curry._1(parse$1, {
                    visited: param.visited,
                    unvisited: param.unvisited,
                    params: param.params,
                    value: subValue
                  });
              return Belt_List.map(parsed, (function (param) {
                            return mapHelp(value, param);
                          }));
            }),
          [Symbol.for("name")]: "Parser"
        };
}

function $eq$great$great(p, s) {
  return {
          hd: map(s, p),
          tl: /* [] */0
        };
}

function oneOf(parsers) {
  return {
          _0: (function (state) {
              return Belt_List.flatten(Belt_List.map(parsers, (function (parse) {
                                return Curry._1(parse._0, state);
                              })));
            }),
          [Symbol.for("name")]: "Parser"
        };
}

var top = {
  _0: (function (state) {
      return {
              hd: state,
              tl: /* [] */0
            };
    }),
  [Symbol.for("name")]: "Parser"
};

function parseHelp(_states) {
  while(true) {
    var states = _states;
    if (!states) {
      return ;
    }
    var rest = states.tl;
    var state = states.hd;
    var match = state.unvisited;
    if (!match) {
      return Caml_option.some(state.value);
    }
    if (match.hd === "") {
      if (!match.tl) {
        return Caml_option.some(state.value);
      }
      _states = rest;
      continue ;
    }
    _states = rest;
    continue ;
  };
}

function splitUrl(url) {
  var segments = Belt_List.fromArray(url.split("/"));
  if (segments && segments.hd === "") {
    return segments.tl;
  } else {
    return segments;
  }
}

function parse(parse$1, parsedUrl, params) {
  return parseHelp(Curry._1(parse$1._0, {
                  visited: /* [] */0,
                  unvisited: parsedUrl,
                  params: params,
                  value: (function (v) {
                      return v;
                    })
                }));
}

function parseRouterUrl(parser, url) {
  return parse(parser, url.path, ReactHelper$ReactTemplate.Router.routeToqueryParamMap(url));
}

var $neg$great$great = Belt_List.concat;

function $pipe$question(parser, queryParser) {
  var queryParser$1 = queryParser._0;
  var parser$1 = parser._0;
  return {
          _0: (function (state) {
              return Belt_List.flatten(Belt_List.map(Curry._1(parser$1, state), queryParser$1));
            }),
          [Symbol.for("name")]: "Parser"
        };
}

function customParam(key, func) {
  return {
          _0: (function (param) {
              var params = param.params;
              return {
                      hd: {
                        visited: param.visited,
                        unvisited: param.unvisited,
                        params: params,
                        value: Curry._1(param.value, Curry._1(func, Belt_MapString.get(params, key)))
                      },
                      tl: /* [] */0
                    };
            }),
          [Symbol.for("name")]: "QueryParser"
        };
}

function stringParam(name) {
  return customParam(name, (function (v) {
                return v;
              }));
}

function intParam(name) {
  return customParam(name, (function (stringValueOpt) {
                return Belt_Option.flatMap(stringValueOpt, (function (stringValue) {
                              try {
                                return Caml_format.caml_int_of_string(stringValue);
                              }
                              catch (raw_exn){
                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn.RE_EXN_ID === "Failure") {
                                  return ;
                                }
                                throw exn;
                              }
                            }));
              }));
}

function intParamWithDefault(name, $$default) {
  return customParam(name, (function (stringValueOpt) {
                return Belt_Option.getWithDefault(Belt_Option.flatMap(stringValueOpt, (function (stringValue) {
                                  try {
                                    return Caml_format.caml_int_of_string(stringValue);
                                  }
                                  catch (raw_exn){
                                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                    if (exn.RE_EXN_ID === "Failure") {
                                      return $$default;
                                    }
                                    throw exn;
                                  }
                                })), $$default);
              }));
}

function toRoute(s, p) {
  return {
          hd: map(s, p),
          tl: /* [] */0
        };
}

function andThen(a, b, v) {
  return Curry._1(b, Curry._1(a, v));
}

function home(v1, v2) {
  return {
          TAG: 0,
          _0: v1,
          _1: v2,
          [Symbol.for("name")]: "Home"
        };
}

function ab(v, v2) {
  return {
          TAG: 1,
          _0: v,
          _1: v2,
          [Symbol.for("name")]: "AB"
        };
}

function start(param) {
  console.log("Start");
  var homeRoute2 = toRoute(home, $slash($slash(top, custom("STRING", (function (v) {
                      return {
                              TAG: 0,
                              _0: v,
                              [Symbol.for("name")]: "Ok"
                            };
                    }))), custom("STRING", (function (v) {
                  return {
                          TAG: 0,
                          _0: v,
                          [Symbol.for("name")]: "Ok"
                        };
                }))));
  var homeRoute = $eq$great$great($slash($slash(top, custom("STRING", (function (v) {
                      return {
                              TAG: 0,
                              _0: v,
                              [Symbol.for("name")]: "Ok"
                            };
                    }))), custom("STRING", (function (v) {
                  return {
                          TAG: 0,
                          _0: v,
                          [Symbol.for("name")]: "Ok"
                        };
                }))), home);
  var abRoute = $eq$great$great($pipe$question($slash($slash($slash(top, custom("STRING", (function (v) {
                              return {
                                      TAG: 0,
                                      _0: v,
                                      [Symbol.for("name")]: "Ok"
                                    };
                            }))), s("fail")), s("hoge")), customParam("name", (function (v) {
                  return v;
                }))), ab);
  var parser = oneOf(Belt_List.concat(Belt_List.concat(abRoute, homeRoute), homeRoute2));
  var parsed = parseRouterUrl(parser, ReasonReactRouter.dangerouslyGetInitialUrl(undefined));
  ReasonReactRouter.watchUrl(function (param) {
        console.log(Belt_Option.getWithDefault(parseRouterUrl(parser, param), /* NotFound */0));
        
      });
  console.log(parsed);
  
}

var Sample = {
  andThen: andThen,
  $great$great: andThen,
  home: home,
  ab: ab,
  start: start
};

exports.custom = custom;
exports.s = s;
exports.string = string;
exports.$$int = $$int;
exports.$slash = $slash;
exports.mapHelp = mapHelp;
exports.map = map;
exports.$eq$great$great = $eq$great$great;
exports.oneOf = oneOf;
exports.top = top;
exports.parseHelp = parseHelp;
exports.splitUrl = splitUrl;
exports.parse = parse;
exports.parseRouterUrl = parseRouterUrl;
exports.$neg$great$great = $neg$great$great;
exports.$pipe$question = $pipe$question;
exports.customParam = customParam;
exports.stringParam = stringParam;
exports.intParam = intParam;
exports.intParamWithDefault = intParamWithDefault;
exports.toRoute = toRoute;
exports.Sample = Sample;
/* ReasonReactRouter Not a pure module */
